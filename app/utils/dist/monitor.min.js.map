{"version":3,"sources":["monitor.js"],"names":["monitorState","isRunning","lastRun","nextRun","interval","timeoutId","getMonitorState","_objectSpread","_objectWithoutProperties","startMonitor","callback","log","console","concat","scheduleNextRun","regeneratorRuntime","async","_context","prev","next","Date","toISOString","now","awrap","clearTimeout","abrupt","t0","error","setTimeout","finish","stop","stopMonitor"],"mappings":"m3CAKA,IAAIA,aAAe,CACjBC,WAAW,EACXC,QAAS,KACTC,QAAS,KACTC,SAAU,IACVC,UAAW,MAQN,SAASC,kBAlBhBN,aAAAK,UAEA,OAAAE,cAAA,GAgBkCC,yBAlBlCR,aAkBkC,CAAA,eAThCI,SAAUK,aAJOC,GAII,GAAAV,aAAAC,UACrBI,QAASM,IAAE,oCAyBX,GAAwB,mBAAbD,EAAX,CAhBAV,aAAAC,WAAA,EADgCW,QAExBP,IAFwB,gCAAAQ,OAAAb,aAAAI,SAAA,IAAA,eAGhC,SAAAU,IAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAE,MAAA,KAAA,EAAA,GACDnB,aAAAE,SAAA,IAAAkB,MAAAC,cAEDrB,aAAAG,QAAA,IAAAiB,KAAAA,KAAAE,MAAAtB,aAAAI,UAAAiB,cAuBIT,QAAQD,IAAR,0CAAAE,OAAsDb,aAAaG,UA1BrEc,EAAAC,KAAA,EA6B4B,mBAAbR,EA7Bf,OAAAO,EAAAE,KAAA,EAAAJ,mBAAAQ,MA8BYb,KA9BZO,EAAAE,KAAA,EAAA,MAAA,KAAA,EAAAF,EAAAE,KAAA,GAAA,MAAA,KAAA,EAAA,OAQInB,QAAAA,MAAaC,qDAAWS,GAE1Bc,aAAAxB,aAAAK,WAGFL,aAAAC,WAAA,EAbAgB,EAAAQ,OAAA,UAAA,KAAA,GAAAR,EAAAE,KAAA,GAAA,MAAA,KAAA,GAAAF,EAAAC,KAAA,GAAAD,EAAAS,GAAAT,EAAA,MAAA,GAeEL,QAAQe,MAAM,sCAAdf,EAAAA,IAfF,KAAA,GAAA,OAAAK,EAAAC,KAAA,GA0CIlB,aAAaK,UAAYuB,WAAWd,EAAiBd,aAAaI,UA1CtEa,EAAAY,OAAA,IAAA,KAAA,GAAA,IAAA,MAAA,OAAAZ,EAAAa,SAAA,KAAA,KAAA,CAAA,CAAA,EAAA,GAAA,GAAA,MAuBwBhB,QARtBF,QAAQe,MAAM,mFAAoFjB,GAWlGE,SAAAA,cAHsBZ,aAAAC,WAAAuB,aAAAxB,aAAAK,WAqCxBL,aAAaC,WAAY,EArCDD,aAAAG,QAAA,KAAAH,aAAAK,UAAA,KAwCxBO,QAAQD,IAAI,qBARVC,QAAQD,IAAI,2BArBRa,SAAAA,cAAaxB,GA4CnB,OA3CMA,aAAAA,UAZkB+B,cAAAtB,aAAAC,GAuDjBV,aAAaC","file":"monitor.min.js","sourcesContent":["// app/utils/monitor.js\r\n\r\n// In a real application, this state would be persisted in a database (e.g., Firestore)\r\n// or a file to maintain state across server restarts or multiple instances.\r\n// For this example, it's an in-memory object, meaning it will reset if the server restarts.\r\nlet monitorState = {\r\n  isRunning: false,\r\n  lastRun: null,\r\n  nextRun: null,\r\n  interval: 30 * 1000, // 30 seconds\r\n  timeoutId: null, // To store the setTimeout ID for clearing\r\n};\r\n\r\n/**\r\n * Retrieves the current state of the monitor.\r\n * Excludes the non-serializable `timeoutId` property.\r\n * @returns {Object} The current monitor state.\r\n */\r\nexport function getMonitorState() {\r\n  // Return a copy of monitorState, explicitly omitting the timeoutId\r\n  const { timeoutId, ...serializableMonitorState } = monitorState;\r\n  return { ...serializableMonitorState };\r\n}\r\n\r\n/**\r\n * Starts the monitor timer.\r\n * @param {Function} callback - The function to execute when the timer fires.\r\n */\r\nexport function startMonitor(callback) {\r\n  if (monitorState.isRunning) {\r\n    console.log(\"Monitor is already running.\");\r\n    return;\r\n  }\r\n\r\n  // Add a type check to ensure callback is a function\r\n  if (typeof callback !== 'function') {\r\n    console.error(\"Error: startMonitor received a non-function callback. Monitor cannot be started.\", callback);\r\n    return;\r\n  }\r\n\r\n  monitorState.isRunning = true;\r\n  console.log(`Monitor started. Next run in ${monitorState.interval / 1000} seconds.`);\r\n\r\n  // Make scheduleNextRun async to properly await the callback\r\n  const scheduleNextRun = async () => {\r\n    monitorState.lastRun = new Date().toISOString();\r\n    monitorState.nextRun = new Date(Date.now() + monitorState.interval).toISOString();\r\n    console.log(`Executing scheduled task. Next run at: ${monitorState.nextRun}`);\r\n    try {\r\n      // Ensure callback is still a function before calling (defensive check)\r\n      if (typeof callback === 'function') {\r\n        await callback(); // Await the async function\r\n      } else {\r\n        console.error(\"Error: Scheduled callback is no longer a function:\", callback);\r\n        // If callback somehow becomes invalid, stop scheduling further runs\r\n        clearTimeout(monitorState.timeoutId);\r\n        monitorState.isRunning = false;\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      console.error(\"‚ùå Error executing monitor callback:\", error);\r\n    } finally {\r\n      // Reschedule the next run, even if the current callback failed\r\n      monitorState.timeoutId = setTimeout(scheduleNextRun, monitorState.interval);\r\n    }\r\n  };\r\n\r\n  // Initial immediate run, then schedule subsequent runs\r\n  scheduleNextRun();\r\n}\r\n\r\n/**\r\n * Stops the monitor timer.\r\n */\r\nexport function stopMonitor() {\r\n  if (!monitorState.isRunning) {\r\n    console.log(\"Monitor is not running.\");\r\n    return;\r\n  }\r\n\r\n  clearTimeout(monitorState.timeoutId);\r\n  monitorState.isRunning = false;\r\n  monitorState.nextRun = null;\r\n  monitorState.timeoutId = null; // Clear the timeoutId when stopped\r\n  console.log(\"Monitor stopped.\");\r\n}\r\n\r\n/**\r\n * Toggles the monitor state (starts if stopped, stops if running).\r\n * @param {Function} callback - The function to execute when the timer fires (only relevant if starting).\r\n * @returns {boolean} The new state of isRunning.\r\n */\r\nexport function toggleMonitor(callback) {\r\n  if (monitorState.isRunning) {\r\n    stopMonitor();\r\n  } else {\r\n    // Pass the callback to startMonitor\r\n    startMonitor(callback);\r\n  }\r\n  return monitorState.isRunning;\r\n}\r\n"]}