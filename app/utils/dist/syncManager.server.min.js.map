{"version":3,"sources":["syncManager.server.js"],"names":["_productSyncServer","require","syncJobState","isRunning","intervalId","lastServerSync","serverSyncCount","syncInterval","errors","authPayload","getServerSyncStatus","slice","performSync","syncResult","regeneratorRuntime","async","_context","prev","next","console","log","awrap","syncProductsWithShopify","sent","Date","toISOString","message","length","error","push","timestamp","type","abrupt","t0","success","concat","stop","startServerSyncJob","intervalMs","initialSyncResult","_args3","arguments","_context3","undefined","setInterval","_context2","status","clearInterval","stopServerSyncJob","updateSyncInterval","_context4","performManualSync","_context5","getSyncStatistics","_objectSpread","uptime","now","getTime","nextSyncIn","healthStatus","recentErrors","clearSyncErrors","errorCount","process","on"],"mappings":"yZACA,IAAAA,mBAAAC,QAAA,gwBAQA,IAAIC,aAAe,CACjBC,WAAW,EACXC,WAAY,KACZC,eAAgB,KAChBC,gBAAiB,EAZnBC,aAAA,IAcEC,OAAQ,GACRC,YAAa,MAOR,SAASC,sBACd,MAAO,CACLP,UAAWD,aAAaC,UAjB5BE,eAAAH,aAAAG,eACIH,gBAAeA,aAAAI,gBACjBH,aADiBD,aAAAK,aAEjBH,OAAUF,aAFOM,OAAAG,OAAA,IA6BnB,SAAeC,YAAYH,GAA3B,IAAAI,EAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAE,MAAA,KAAA,EAAA,OAAAF,EAAAC,KAAA,EAEIE,QAAQC,IAAI,uCAFhBJ,EAAAE,KAAA,EAAAJ,mBAAAO,OAI6B,EAAArB,mBAAAsB,yBAAwBb,IAJrD,KAAA,EAAA,OAIUI,EAJVG,EAAAO,KAdErB,aAAOG,gBAAA,IAAAmB,MAAAC,cACLtB,aAAWD,kBAGXK,EAAcL,SACdM,QAAQN,IAARM,wCAAsCK,EAAAa,SAEzC,EAAAxB,aAAAM,OAAAmB,SAEDzB,aAAAM,OAAA,MAwBMW,QAAQS,MAAM,wBAAyBf,EAAWe,OAGlD1B,aAAaM,OAAOqB,KAAK,CAtB/BC,WAAelB,IAAYH,MAAAA,cAA3BmB,MAAAf,EAAAe,MAAAG,KAAA,iBAAA,GAAA7B,aAAAM,OAAAmB,SAEIR,aAAAX,OAAYN,aAAAM,OAAAG,OAAA,MAFhBK,EAAAgB,OAAA,SAAAnB,GAAA,KAAA,GAAA,OAAAG,EAAAC,KAAA,GAAAD,EAAAiB,GAAAjB,EAAA,MAAA,GAOId,QAAAA,MAAAA,iCAAAA,EAAAA,IAIAA,aAAIW,OAAUgB,KAACK,CACbf,WAAAA,IAAQC,MAARK,cA8BAG,MAAOZ,EAAAiB,GAAMP,QA3BbK,KAAA,gBAfNf,EAAAgB,OAAA,SAWI,CAQEb,SAAAA,EA6BAS,MAAK,qBAAAO,OAAuBnB,EAAAiB,GAAMP,SA1BlCxB,gBAAAA,GACE4B,gBAAS,GACTF,OAAAA,KAxBR,KAAA,GAAA,IAAA,MAAA,OAAAZ,EAAAoB,SAAA,KAAA,KAAA,CAAA,CAAA,EAAA,MAAA,SAAAC,mBAAA5B,GAAA,IAAA6B,EAAAC,EAAAC,EAAAC,UAAA,OAAA3B,mBAAAC,MAAA,SAAA2B,GAAA,OAAA,OAAAA,EAAAzB,KAAAyB,EAAAxB,MAAA,KAAA,EAAA,OAAAoB,EAAA,EAAAE,EAAAb,aAAAgB,IAAAH,EAAA,GAAAA,EAAA,GAAA,IAAAE,EAAAzB,KAAA,EAqCIE,aAAQS,YA6BNT,QAAQC,IAAI,4DA1BdlB,qBAAyBA,aAAzBO,YAAAA,EAxCJP,aAAAK,aAAA+B,EAgDMV,QAAAA,IAAAA,yCAAAA,OAA4BU,EAA5BV,mBAhDNc,EAAAxB,KAAA,EAAAJ,mBAAAO,MAmDcT,YAAAH,IAnDd,KAAA,EAAA,OAmDMD,EAnDNkC,EAAAnB,KAAArB,aAAAE,WAAAwC,YAAA,WAAA,OAAA9B,mBAAAC,MAAA,SAAA8B,GAAA,OAAA,OAAAA,EAAA5B,KAAA4B,EAAA3B,MAAA,KAAA,EAAA,GAAAhB,aAAAC,WAAAD,aAAAO,YAAA,OAAAoC,EAAA3B,KAAA,EAAAJ,mBAAAO,MAAAT,YAAAV,aAAAO,cAAAoC,EAAA3B,KAAA,EAAA,MAAA,KAAA,EAAA,IAAA,MAAA,OAAA2B,EAAAT,WAAAE,GAwDApC,aAAAC,WAAA,EAiCIgB,QAAQC,IAAI,+CAzFhBsB,EAAAV,OAAA,SA2FW,CACLE,SAAS,EACTR,QAAO,gCAAAS,OAAkCG,EAAlC,eACPC,kBAAAA,EAhCCO,OAAeT,wBA9DtB,KAAA,GAAA,OAAAK,EAAAzB,KAAA,GAAAyB,EAAAT,GAAAS,EAAA,MAAA,GA8DOvB,QAAAS,MAAA,qCAAAc,EAAAT,IAAA/B,aAAAC,WAAA,EAA+CmC,aAAAA,YAA/C,KA2CCpC,aAAaE,aAzCjB2C,cAAA7C,aAAAE,YACAF,aAAIA,WAAaC,MAjErBuC,EAAAV,OAAA,SA8DO,CAiDDE,SAAS,EACTR,QAAO,oCAAAS,OAAsCO,EAAAT,GAAMP,SAzCrDxB,MAAAA,EAAAA,GAAAA,UAvEJ,KAAA,GAAA,IAAA,MAAA,OAAAwC,EAAAN,SAAA,KAAA,KAAA,CAAA,CAAA,EAAA,MA+EI,SAAAY,oBACA9C,IAAsC,OAAAA,aAAAC,WAAAgB,QAAAC,IAAA,uCAAAlB,aAAAE,aAAA2C,cAAA7C,aAAAE,YAAAF,aAAAE,WAAA,MAAAF,aAInCoC,WAEH,EAyDApC,aAAaO,YAAc,KAtD3BU,QAAAA,IAAAA,+CAGEe,CACAR,SAAAA,EACAa,QAAAA,uCACAO,OAAAA,yBAfoC3B,QAAAC,IAAA,qCAAA,CAAAc,SAAA,EAAAR,QAAA,kCAAAoB,OAAApC,wBAlBnC,MAAAkB,GA2CH,OA3CGT,QAAAS,MAAA,oCAAAA,GA+FH1B,aAAaC,WAAY,EAvDzBD,aAAAA,YAAaC,KACbD,aAAAA,WAAaO,KAEb,CACEsC,SAAAA,EACA7C,QAAAA,mCAAAA,OAAA0B,EAAAF,SACDE,MAAAA,EAAAF,UA9CE,SAAAuB,mBAAAX,GAAA,IAAA,OAAApC,aAAAC,WAyHHgB,QAAQC,IAAR,gCAAAe,OAA4CG,EAA5C,UA5DEpC,aAAAE,YACF2C,cAAK7C,aAAwBE,YAIzBsB,aAASnB,aAAA+B,EACTQ,aAAQpC,WAAAA,YAAmB,WAAA,OAAAI,mBAAAC,MAAA,SAAAmC,GAAA,OAAA,OAAAA,EAAAjC,KAAAiC,EAAAhC,MAAA,KAAA,EAAA,GAH7BhB,aAAAC,WAAAD,aAAAO,YAG6B,OAAAyC,EAAAhC,KAAA,EAAAJ,mBAAAO,MAE9BT,YAAAV,aAAAO,cAF8ByC,EAAAhC,KAAA,EAAA,MAAA,KAAA,EAAA,IAAA,MAAA,OAAAgC,EAAAd,WAI/BjB,GAGAA,QAAIjB,IAAAA,wCAEFA,CAGFgC,SAAA,EA6DER,QAAO,4BAAAS,OAA8BG,EAA9B,MACPQ,OAAQpC,wBA7IP,CAAAwB,SAAA,EAwDPR,QAAA,oDA2BIP,MAAOS,GAILF,OAFFP,QAAOS,MAAA,kCAAAA,GAELF,CACAoB,SAAQpC,EAHVgB,QAAA,iCAAAS,OAAAP,EAAAF,SAMAE,MAAOA,EAAOF,UAQd,SAAAyB,kBAAA1C,GAAA,IAAAI,EAAA,OAAAC,mBAAAC,MAAA,SAAAqC,GAAA,OAAA,OAAAA,EAAAnC,KAAAmC,EAAAlC,MAAA,KAAA,EAAA,OAAAkC,EAAAnC,KAAA,EAMHE,QAAAC,IAAA,gCANGgC,EAAAlC,KAAA,EAAAJ,mBAAAO,OAiEyB,EAAArB,mBAAAsB,yBAAwBb,IAjEjD,KAAA,EAAA,OAiEMI,EAjENuC,EAAA7B,KAmEAJ,QAAQC,IAAI,2BAnEZgC,EAAApB,OAAA,SAqEO,CACLE,SAAS,EAzDRR,QAASuB,wBACVpC,WAAAA,EACFiC,OAAK5C,wBAfL,KAAA,EAAA,OAAAkD,EAAAnC,KAAA,EAAAmC,EAAAnB,GAAAmB,EAAA,MAAA,GAgBSjC,QAAPS,MAAA,wBAAOwB,EAAAnB,IAhBTmB,EAAApB,OAAA,SA+EO,CAzDPb,SAAA,EA2DEO,QAAO,uBAAAS,OAAyBiB,EAAAnB,GAAMP,SAxDxCE,MAAI1B,EAAAA,GAAAA,UAzBJ,KAAA,GAAA,IAAA,MAAA,OAAAkD,EAAAhB,SAAA,KAAA,KAAA,CAAA,CAAA,EAAA,KA+BsC,SAAAiB,oBAAA,OAAAC,cAAA,GAAA5C,sBAAA,CAAA6C,OAAArD,aAAAC,UAAAqB,KAAAgC,MAAA,IAAAhC,KAAAtB,aAAAG,gBAAAmB,KAAAgC,OAAAC,UAAA,EAAAC,WAAAxD,aAAAC,UAAAD,aAAAK,aAAA,KAAAoD,aAAA,EAAAzD,aAAAM,OAAAmB,OAAA,UAAA,UAkEtCiC,aAAc1D,aAAaM,OAAOG,OAAO,KAlEH,SAAAkD,kBAAA,IAAA,IAInCvB,EAJHpC,aAAAM,OAAAmB,OAWEmB,OALF3B,aAAYX,OAAA,GAGV0B,QAAAA,IAAAA,cAAAA,OADK4B,EACL5B,iBAEAY,CAHFZ,SAAA,EAMAR,QAAOE,WAAAA,OAAOkC,EAAPlC,gBACPT,OAAQS,uBAINF,MAAAA,GAGH,OAFGE,QAAKA,MAAO,gCAACF,GAEhB,CACFQ,SAAA,EAEDR,QAAA,+BAAAS,OAAAP,EAAAF,SAoEME,MAAOA,EAAMF,6CA/DZqC,QAAAC,GAAeb,UAAAA,WAAfhC,QAAAC,IAAA,6CAAA4B,sBAAAe,QAAAC,GAAA,SAAA,WAAA7C,QAAAC,IAAA,4CAEHD","file":"syncManager.server.min.js","sourcesContent":["// app/utils/syncManager.server.js\r\nimport { syncProductsWithShopify } from '../services/productSync.server.js';\r\n\r\n/**\r\n * Server-side sync manager that handles persistent background synchronization\r\n * This manages a server-side cron-like job that runs at regular intervals\r\n */\r\n\r\n// In-memory storage for sync job state (in production, consider using Redis or database)\r\nlet syncJobState = {\r\n  isRunning: false,\r\n  intervalId: null,\r\n  lastServerSync: null,\r\n  serverSyncCount: 0,\r\n  syncInterval: 30000, // 30 seconds default\r\n  errors: [],\r\n  authPayload: null\r\n};\r\n\r\n/**\r\n * Gets the current status of the server-side sync job\r\n * @returns {Object} Current sync job status\r\n */\r\nexport function getServerSyncStatus() {\r\n  return {\r\n    isRunning: syncJobState.isRunning,\r\n    lastServerSync: syncJobState.lastServerSync,\r\n    serverSyncCount: syncJobState.serverSyncCount,\r\n    syncInterval: syncJobState.syncInterval,\r\n    errors: syncJobState.errors.slice(-5) // Return last 5 errors\r\n  };\r\n}\r\n\r\n/**\r\n * Performs a single sync operation\r\n * @param {Object} authPayload - Shopify authentication payload\r\n * @returns {Promise<Object>} Sync results\r\n */\r\nasync function performSync(authPayload) {\r\n  try {\r\n    console.log('🔄 Starting server-side sync job...');\r\n\r\n    const syncResult = await syncProductsWithShopify(authPayload);\r\n\r\n    // Update sync statistics\r\n    syncJobState.lastServerSync = new Date().toISOString();\r\n    syncJobState.serverSyncCount++;\r\n\r\n    // Log the results\r\n    if (syncResult.success) {\r\n      console.log(`✅ Server sync completed successfully:`, syncResult.message);\r\n\r\n      // Clear old errors on successful sync\r\n      if (syncJobState.errors.length > 0) {\r\n        syncJobState.errors = [];\r\n      }\r\n    } else {\r\n      console.error('❌ Server sync failed:', syncResult.error);\r\n\r\n      // Add error to the error log\r\n      syncJobState.errors.push({\r\n        timestamp: new Date().toISOString(),\r\n        error: syncResult.error,\r\n        type: 'sync_failure'\r\n      });\r\n\r\n      // Keep only last 10 errors\r\n      if (syncJobState.errors.length > 10) {\r\n        syncJobState.errors = syncJobState.errors.slice(-10);\r\n      }\r\n    }\r\n\r\n    return syncResult;\r\n\r\n  } catch (error) {\r\n    console.error('💥 Fatal error in server sync:', error);\r\n\r\n    // Add fatal error to the error log\r\n    syncJobState.errors.push({\r\n      timestamp: new Date().toISOString(),\r\n      error: error.message,\r\n      type: 'fatal_error'\r\n    });\r\n\r\n    return {\r\n      success: false,\r\n      error: `Fatal sync error: ${error.message}`,\r\n      createdProducts: [],\r\n      updatedProducts: [],\r\n      errors: []\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Starts the server-side sync job\r\n * @param {Object} authPayload - Shopify authentication payload\r\n * @param {number} intervalMs - Sync interval in milliseconds (optional)\r\n * @returns {Object} Result of starting the sync job\r\n */\r\nexport async function startServerSyncJob(authPayload, intervalMs = 30000) {\r\n  try {\r\n    // Stop any existing sync job first\r\n    if (syncJobState.isRunning) {\r\n      console.log('🛑 Stopping existing sync job before starting new one...');\r\n      stopServerSyncJob();\r\n    }\r\n\r\n    // Store the auth payload for use in the interval\r\n    syncJobState.authPayload = authPayload;\r\n    syncJobState.syncInterval = intervalMs;\r\n\r\n    console.log(`🚀 Starting server-side sync job with ${intervalMs}ms interval...`);\r\n\r\n    // Perform initial sync\r\n    const initialSyncResult = await performSync(authPayload);\r\n\r\n    // Set up the recurring sync job\r\n    syncJobState.intervalId = setInterval(async () => {\r\n      if (syncJobState.isRunning && syncJobState.authPayload) {\r\n        await performSync(syncJobState.authPayload);\r\n      }\r\n    }, intervalMs);\r\n\r\n    // Mark as running\r\n    syncJobState.isRunning = true;\r\n\r\n    console.log('✅ Server-side sync job started successfully');\r\n\r\n    return {\r\n      success: true,\r\n      message: `Server sync job started with ${intervalMs}ms interval`,\r\n      initialSyncResult,\r\n      status: getServerSyncStatus()\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Failed to start server sync job:', error);\r\n\r\n    // Clean up on failure\r\n    syncJobState.isRunning = false;\r\n    syncJobState.authPayload = null;\r\n\r\n    if (syncJobState.intervalId) {\r\n      clearInterval(syncJobState.intervalId);\r\n      syncJobState.intervalId = null;\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      message: `Failed to start server sync job: ${error.message}`,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Stops the server-side sync job\r\n * @returns {Object} Result of stopping the sync job\r\n */\r\nexport function stopServerSyncJob() {\r\n  try {\r\n    if (!syncJobState.isRunning) {\r\n      console.log('⏸️ Server sync job is not running');\r\n      return {\r\n        success: true,\r\n        message: 'Server sync job was not running',\r\n        status: getServerSyncStatus()\r\n      };\r\n    }\r\n\r\n    console.log('🛑 Stopping server-side sync job...');\r\n\r\n    // Clear the interval\r\n    if (syncJobState.intervalId) {\r\n      clearInterval(syncJobState.intervalId);\r\n      syncJobState.intervalId = null;\r\n    }\r\n\r\n    // Mark as stopped\r\n    syncJobState.isRunning = false;\r\n    syncJobState.authPayload = null;\r\n\r\n    console.log('✅ Server-side sync job stopped successfully');\r\n\r\n    return {\r\n      success: true,\r\n      message: 'Server sync job stopped successfully',\r\n      status: getServerSyncStatus()\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Error stopping server sync job:', error);\r\n\r\n    // Force cleanup\r\n    syncJobState.isRunning = false;\r\n    syncJobState.authPayload = null;\r\n    syncJobState.intervalId = null;\r\n\r\n    return {\r\n      success: false,\r\n      message: `Error stopping server sync job: ${error.message}`,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Updates the sync interval for the running job\r\n * @param {number} intervalMs - New interval in milliseconds\r\n * @returns {Object} Result of updating the interval\r\n */\r\nexport function updateSyncInterval(intervalMs) {\r\n  try {\r\n    if (!syncJobState.isRunning) {\r\n      return {\r\n        success: false,\r\n        message: 'Cannot update interval - sync job is not running'\r\n      };\r\n    }\r\n\r\n    console.log(`⏱️ Updating sync interval to ${intervalMs}ms...`);\r\n\r\n    // Clear existing interval\r\n    if (syncJobState.intervalId) {\r\n      clearInterval(syncJobState.intervalId);\r\n    }\r\n\r\n    // Set new interval\r\n    syncJobState.syncInterval = intervalMs;\r\n    syncJobState.intervalId = setInterval(async () => {\r\n      if (syncJobState.isRunning && syncJobState.authPayload) {\r\n        await performSync(syncJobState.authPayload);\r\n      }\r\n    }, intervalMs);\r\n\r\n    console.log('✅ Sync interval updated successfully');\r\n\r\n    return {\r\n      success: true,\r\n      message: `Sync interval updated to ${intervalMs}ms`,\r\n      status: getServerSyncStatus()\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Error updating sync interval:', error);\r\n\r\n    return {\r\n      success: false,\r\n      message: `Error updating sync interval: ${error.message}`,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Performs a manual sync without affecting the scheduled job\r\n * @param {Object} authPayload - Shopify authentication payload\r\n * @returns {Promise<Object>} Manual sync results\r\n */\r\nexport async function performManualSync(authPayload) {\r\n  try {\r\n    console.log('🔧 Performing manual sync...');\r\n\r\n    const syncResult = await syncProductsWithShopify(authPayload);\r\n\r\n    console.log('✅ Manual sync completed');\r\n\r\n    return {\r\n      success: true,\r\n      message: 'Manual sync completed',\r\n      syncResult,\r\n      status: getServerSyncStatus()\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Manual sync failed:', error);\r\n\r\n    return {\r\n      success: false,\r\n      message: `Manual sync failed: ${error.message}`,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Gets detailed sync statistics and health information\r\n * @returns {Object} Detailed sync statistics\r\n */\r\nexport function getSyncStatistics() {\r\n  return {\r\n    ...getServerSyncStatus(),\r\n    uptime: syncJobState.isRunning ? Date.now() - new Date(syncJobState.lastServerSync || Date.now()).getTime() : 0,\r\n    nextSyncIn: syncJobState.isRunning ? syncJobState.syncInterval : null,\r\n    healthStatus: syncJobState.errors.length > 0 ? 'warning' : 'healthy',\r\n    recentErrors: syncJobState.errors.slice(-3)\r\n  };\r\n}\r\n\r\n/**\r\n * Clears all stored errors\r\n * @returns {Object} Result of clearing errors\r\n */\r\nexport function clearSyncErrors() {\r\n  try {\r\n    const errorCount = syncJobState.errors.length;\r\n    syncJobState.errors = [];\r\n\r\n    console.log(`🧹 Cleared ${errorCount} sync errors`);\r\n\r\n    return {\r\n      success: true,\r\n      message: `Cleared ${errorCount} sync errors`,\r\n      status: getServerSyncStatus()\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Error clearing sync errors:', error);\r\n\r\n    return {\r\n      success: false,\r\n      message: `Error clearing sync errors: ${error.message}`,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Graceful shutdown handler\r\nprocess.on('SIGTERM', () => {\r\n  console.log('📴 Received SIGTERM, stopping sync job...');\r\n  stopServerSyncJob();\r\n});\r\n\r\nprocess.on('SIGINT', () => {\r\n  console.log('📴 Received SIGINT, stopping sync job...');\r\n  stopServerSyncJob();\r\n});\r\n\r\n// Export the sync state for debugging purposes (remove in production)\r\nexport { syncJobState as _syncJobState };\r\n"]}